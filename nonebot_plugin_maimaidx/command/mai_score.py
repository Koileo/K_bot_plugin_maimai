import hashlib
import json
import os
import random
import datetime
import re
import socket
import ssl
import time
import zlib
from datetime import datetime, timedelta
from nonebot import on_command, on_regex, on_startswith
import nonebot
import requests
from nonebot import on_command , on_fullmatch
from nonebot.adapters.onebot.v12 import MessageSegment
from nonebot.log import logger
from nonebot.matcher import Matcher
from nonebot.params import EventMessage
from nonebot.permission import SUPERUSER
from nonebot.adapters.onebot.v11 import GroupMessageEvent, Message, MessageEvent
from nonebot.params import CommandArg, Depends
from ..libraries.maimaidx_best_suo50 import generate_suo
from ..libraries.maimaidx_best_dongfang import generate_dongfang
from ..libraries.maimaidx_best_cun50 import generate_cun
from ..libraries.maimaidx_best_vocaloid import generate_volcaloid
from ..libraries.maimaidx_best_40 import generate_2
from ..libraries.maimaidx_best_ap50 import generate_ap
from ..libraries.maimaidx_best_app50 import generate_app
from ..libraries.maimaidx_best_niubi50 import generate_niubi
from ..libraries.maimaidx_best_expert50 import generate_expert
from ..libraries.maimaidx_best_basic50 import generate_basic
from ..libraries.maimaidx_best_master50 import generate_master
from ..libraries.maimaidx_best_remaster50 import generate_remaster
from ..libraries.maimaidx_best_advanced50 import generate_advanced
from ..libraries.maimaidx_best_anime import generate_anime
from ..libraries.maimaidx_best_yue50 import generate_yue
from ..libraries.maimaidx_best_50_upscale_all import generate_upscaleall
from ..libraries.maimaidx_best_fc50 import generate_fc
from ..libraries.maimaidx_best_3star_50 import generate_star3
from ..libraries.maimaidx_best_4star_50 import generate_star4
from ..libraries.maimaidx_best_5star_50 import generate_star5
from ..libraries.maimaidx_nihe_50 import generate_nihe
from ..libraries.maimaidx_best_allb50 import generate_allb50
from ..libraries.maimaidx_best_allb100 import generate_allb100
from ..libraries.maimaidx_best_pc50 import generate_pcb50
from ..libraries.maimaidx_music_info import *
from ..libraries.maimaidx_player_score import *
from ..libraries.maimaidx_update_plate import *
from playwright.async_api import async_playwright
import matplotlib.pyplot as plt
import numpy as np
from io import BytesIO
from ..libraries.maimaidx_generate_card import generate_image_maicard

def check_time() -> bool:

    current_hour = datetime.now().hour
    if 2 <= current_hour < 9:
        return False
    else:
        return True


def get_at_qq(message: GroupMessageEvent) -> Optional[int]:
    for item in message:
        if isinstance(item, MessageSegment) and item.type == 'at' and item.data['qq'] != 'all':
            return int(item.data['qq'])
    return None


async def generate_rank_distribution(username: str, rating: int, rank_index: int, rankdata: list):
    total_players = len(rankdata)
    percentage = 100 - round(rank_index / total_players * 100, 2)
    average_ra = sum(user['ra'] for user in rankdata) / len(rankdata)

    ratings = [user['ra'] for user in rankdata]
    bins = list(range(0, 17001, 1000))

    hist, bin_edges = np.histogram(ratings, bins=bins)

    plt.figure(figsize=(12, 6))

    colors = plt.cm.Blues(np.linspace(0.3, 1, len(bins) - 1))
    bars = plt.bar(bin_edges[:-1], hist, width=1000, align='edge', color=colors, alpha=0.7)

    plt.axvline(x=rating, color='red', linestyle='--', linewidth=2, label=f'你的Rating: {rating}')

    plt.text(rating + 50, max(hist) * 0.9,
             f'Your Rating: {rating}\n Rank: {rank_index}/{total_players}\nBeyond {percentage}% player',
             color='red', bbox=dict(facecolor='white', alpha=0.8))

    plt.title(f'MaiMaiDX Rating（{username}）', fontsize=16, pad=20)
    plt.xlabel('Rating     Generated by Cachebot', fontsize=12)
    plt.ylabel('Number of people', fontsize=12)
    plt.xticks(bins, rotation=45)
    plt.grid(axis='y', linestyle='--', alpha=0.5)

    plt.axvline(x=average_ra, color='green', linestyle=':', linewidth=2, label=f'Averaged Rating: {average_ra:.1f}')
    plt.legend()

    buf = BytesIO()
    plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
    buf.seek(0)
    img = Image.open(buf)
    plt.close()

    return img


best50  = on_command('b50', aliases={'B50','maib50'})
best40  = on_command('b40', aliases={'B40','maib40'})
bestap50  = on_command('ap50', aliases={'APB50','apb50','maiap50'})
bestapp50  = on_command('ap+50', aliases={'理论50','appb50','理论b50','ap+b50'})
fullcombo50  = on_command('fc50', aliases={'fcB50','fcb50','maifc50'})
niheb50  = on_command('拟合50', aliases={'拟合b50','f50','nh50','niheb50','nihe50'})
star3b50 = on_command("三星b50",aliases={'三星50','3星50','3星b50'})
star4b50 = on_command("四星b50",aliases={'四星50','4星50','4星b50'})
star5b50 = on_command("五星b50",aliases={'五星50','5星50','5星b50'})
ab50 = on_command("ab50",aliases={'allb50','all50'})
b100 = on_command("b100")
minfo   = on_command('minfo', aliases={'minfo', 'Minfo', 'MINFO', 'info', 'Info', 'INFO'})
ginfo   = on_command('ginfo', aliases={'ginfo', 'Ginfo', 'GINFO'})
score   = on_command('分数线')
rank = on_command('排名',aliases={'水鱼排名', '我有多菜'}, priority=20)
infoget = on_command('数据获取', priority=20, permission=SUPERUSER)
cun50 = on_command("寸止50",aliases={'寸b50','寸50','寸止b50','性50','性b50'})
volcaloid50 = on_command("术力口50",aliases={'术力口b50','VOCALOID50','术b50','术50'})
suo50 = on_command("锁血50",aliases={'锁血b50','锁50','锁b50'})
dongfang50 = on_command("东方50",aliases={'东方b50'})
anime50 = on_command("动漫b50",aliases={'动漫50','流行50','流行b50'})
niubi50 = on_command("牛逼50",aliases={'牛逼b50'})
basic50 = on_command("绿50",aliases={'绿铺b50','绿b50','basic50','basicb50','绿铺50'})
advanced50 = on_command("黄50",aliases={'黄铺b50','黄b50','advanced50','advancedb50','黄铺50'})
expert50 = on_command("红50",aliases={'红铺b50','红b50','expert50','expertb50','红铺50'})
master50 = on_command("紫50",aliases={'紫铺b50','紫b50','master50','masterb50','紫铺50'})
remaster50 = on_command("白50",aliases={'白铺b50','白b50','remaster50','remasterb50','白铺50'})
beast50upscaleall = on_command("理想b50",aliases={'理想50'})
networkmonitor = on_command("舞萌状态",aliases={'网络状况','网咋样'})
yue50 = on_command("越级50",aliases={'越50','越级b50','越级50'})
@best50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    user_qq = event.get_user_id()
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate(qqid, username), reply_message=True)

@best40.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_2(qqid, username), reply_message=True)


@bestap50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_ap(qqid, username), reply_message=True)

@bestapp50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_app(qqid, username), reply_message=True)

@fullcombo50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_fc(qqid, username), reply_message=True)

@star3b50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_star3(qqid, username), reply_message=True)

@star4b50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_star4(qqid, username), reply_message=True)


@star5b50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_star5(qqid, username), reply_message=True)

@niheb50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_nihe(qqid, username), reply_message=True)

@ab50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_allb50(qqid, username), reply_message=True)

@b100.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_allb100(qqid, username), reply_message=True)

@cun50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_cun(qqid, username), reply_message=True)

@volcaloid50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_volcaloid(qqid, username), reply_message=True)

@dongfang50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_dongfang(qqid, username), reply_message=True)

@suo50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_suo(qqid, username), reply_message=True)

@anime50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_anime(qqid, username), reply_message=True)

@basic50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_basic(qqid, username), reply_message=True)

@expert50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_expert(qqid, username), reply_message=True)

@advanced50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_advanced(qqid, username), reply_message=True)

@yue50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_yue(qqid, username), reply_message=True)

@master50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_master(qqid, username), reply_message=True)

@remaster50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_remaster(qqid, username), reply_message=True)

@niubi50.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_niubi(qqid, username), reply_message=True)



@beast50upscaleall.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    await matcher.finish(await generate_upscaleall(qqid, username), reply_message=True)


@minfo.handle()
async def _(
        event: MessageEvent,
        message: Message = CommandArg(),
        user_id: Optional[int] = Depends(get_at_qq)
):
    qqid = user_id or event.user_id
    args = message.extract_plain_text().strip()
    if not args:
        await minfo.finish('请输入曲目id或曲名', reply_message=True)

    if mai.total_list.by_id(args):
        music_id = args
    elif by_t := mai.total_list.by_title(args):
        music_id = by_t.id
    else:
        aliases = mai.total_alias_list.by_alias(args)
        if not aliases:
            await minfo.finish('未找到曲目')
        elif len(aliases) != 1:
            msg = '找到相同别名的曲目，请使用以下ID查询：\n'
            for music_id in aliases:
                msg += f'{music_id.SongID}：{music_id.Name}\n'
            await minfo.finish(msg.strip())
        else:
            music_id = str(aliases[0].SongID)

    pic = await draw_music_play_data(qqid, music_id)
    await minfo.finish(pic, reply_message=True)


@ginfo.handle()
async def _(message: Message = CommandArg()):
    args = message.extract_plain_text().strip()
    if not args:
        await ginfo.finish('请输入曲目id或曲名', reply_message=True)
    if args[0] not in '绿黄红紫白':
        level_index = 3
    else:
        level_index = '绿黄红紫白'.index(args[0])
        args = args[1:].strip()
        if not args:
            await ginfo.finish('请输入曲目id或曲名', reply_message=True)
    if mai.total_list.by_id(args):
        id = args
    elif by_t := mai.total_list.by_title(args):
        id = by_t.id
    else:
        alias = mai.total_alias_list.by_alias(args)
        if not alias:
            await ginfo.finish('未找到曲目', reply_message=True)
        elif len(alias) != 1:
            msg = '找到相同别名的曲目，请使用以下ID查询：\n'
            for songs in alias:
                msg += f'{songs.SongID}：{songs.Name}\n'
            await ginfo.finish(msg.strip(), reply_message=True)
        else:
            id = str(alias[0].SongID)

    music = mai.total_list.by_id(id)
    if not music.stats:
        await ginfo.finish('该乐曲还没有统计信息', reply_message=True)
    if len(music.ds) == 4 and level_index == 4:
        await ginfo.finish('该乐曲没有这个等级', reply_message=True)
    if not music.stats[level_index]:
        await ginfo.finish('该等级没有统计信息', reply_message=True)
    stats = music.stats[level_index]
    data = await music_global_data(music, level_index) + dedent(f'''\
        游玩次数：{round(stats.cnt)}
        拟合难度：{stats.fit_diff:.2f}
        平均达成率：{stats.avg:.2f}%
        平均 DX 分数：{stats.avg_dx:.1f}
        谱面成绩标准差：{stats.std_dev:.2f}''')
    await ginfo.finish(data, reply_message=True)


@score.handle()
async def _(message: Message = CommandArg()):
    _args = message.extract_plain_text().strip()
    args = _args.split()
    if args and args[0] == '帮助':
        msg = dedent('''\
            此功能为查找某首歌分数线设计。
            命令格式：分数线 <难度+歌曲id> <分数线>
            例如：分数线 紫799 100
            命令将返回分数线允许的 TAP GREAT 容错以及 BREAK 50落等价的 TAP GREAT 数。
            以下为 TAP GREAT 的对应表：
            GREAT/GOOD/MISS
            TAP    1/2.5/5
            HOLD   2/5/10
            SLIDE  3/7.5/15
            TOUCH  1/2.5/5
            BREAK  5/12.5/25(外加200落)''')
        await score.finish(MessageSegment.image(text_to_bytes_io(msg)), reply_message=True)
    else:
        try:
            result = re.search(r'([绿黄红紫白])\s?([0-9]+)', _args)
            level_labels = ['绿', '黄', '红', '紫', '白']
            level_labels2 = ['Basic', 'Advanced', 'Expert', 'Master', 'Re:MASTER']
            level_index = level_labels.index(result.group(1))
            chart_id = result.group(2)
            line = float(args[-1])
            music = mai.total_list.by_id(chart_id)
            chart = music.charts[level_index]
            tap = int(chart.notes.tap)
            slide = int(chart.notes.slide)
            hold = int(chart.notes.hold)
            touch = int(chart.notes.touch) if len(chart.notes) == 5 else 0
            brk = int(chart.notes.brk)
            total_score = tap * 500 + slide * 1500 + hold * 1000 + touch * 500 + brk * 2500
            break_bonus = 0.01 / brk
            break_50_reduce = total_score * break_bonus / 4
            reduce = 101 - line
            if reduce <= 0 or reduce >= 101:
                raise ValueError
            msg = dedent(f'''\
                {music.title} {level_labels2[level_index]}
                分数线 {line}% 允许的最多 TAP GREAT 数量为 {(total_score * reduce / 10000):.2f}(每个-{10000 / total_score:.4f}%),
                BREAK 50落(一共{brk}个)等价于 {(break_50_reduce / 100):.3f} 个 TAP GREAT(-{break_50_reduce / total_score * 100:.4f}%)''')
            await score.finish(MessageSegment.image(text_to_bytes_io(msg)), reply_message=True)
        except (AttributeError, ValueError) as e:
            log.exception(e)
            await score.finish('格式错误，输入“分数线 帮助”以查看帮助信息', reply_message=True)

@rank.handle()
async def _(event: MessageEvent, matcher: Matcher, arg: Message = CommandArg()):
    user_qq = event.get_user_id()
    qqid = get_at_qq(arg) or event.user_id
    username = arg.extract_plain_text().split()
    if _q := get_at_qq(arg):
        qqid = _q
    if username:
        if username[0].isdigit():
            qqid = int(username[0])
            username = []
    diving_username = await backname(qqid, username)
    rating = await backrating(qqid,username)
    song_file_path = gamedir/'diving_rank_list.json'
    with open(song_file_path, "r", encoding="utf-8") as file:
        rankdata = json.load(file)
    rank_index = 1
    for i in rankdata:
        if i['ra'] < int(rating):
            break
        else:
            rank_index += 1
    total_ra = sum(user['ra'] for user in rankdata)  # 计算所有 ra 的总和
    average_ra = round(total_ra / len(rankdata),2) # 计算平均值
    image_buf = await generate_rank_distribution(diving_username, int(rating), rank_index, rankdata)
    await rank.send(MessageSegment.image(image_to_base64(image_buf)),
                     reply_message=False)
    text_is = '亲爱的'+ str(diving_username) +"玩家你好，你"+str(rating)+"的舞萌rating在水鱼查分器网站排名"+str(rank_index)+"，超越了"+str(100-round(rank_index/len(rankdata)*100,2))+"%的玩家"+"，平均rating为"+str(average_ra)+"，继续加油哦"
    await rank.finish(text_is, reply_message=True)
